var CommonUpdater, InventorySync, InventoryUpdater, Q, _,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

_ = require('underscore')._;

Q = require('q');

CommonUpdater = require('./common-updater');

InventorySync = require('../sync/inventory-sync');

/*
Inventory Updater class
*/


InventoryUpdater = (function(_super) {
  var CHANNEL_REF_NAME;

  __extends(InventoryUpdater, _super);

  CHANNEL_REF_NAME = 'supplyChannel';

  function InventoryUpdater(opts) {
    if (opts == null) {
      opts = {};
    }
    this.processInBatches = __bind(this.processInBatches, this);
    InventoryUpdater.__super__.constructor.call(this, opts);
    this.sync = new InventorySync(opts);
    this.rest = this.sync._rest;
    this.existingInventoryEntries = {};
    this;
  }

  InventoryUpdater.prototype.createInventoryEntry = function(sku, quantity, expectedDelivery, channelId) {
    var entry;
    entry = {
      sku: sku,
      quantityOnStock: parseInt(quantity)
    };
    if (expectedDelivery) {
      entry.expectedDelivery = expectedDelivery;
    }
    if (channelId) {
      entry[CHANNEL_REF_NAME] = {
        typeId: 'channel',
        id: channelId
      };
    }
    return entry;
  };

  InventoryUpdater.prototype.ensureChannelByKey = function(rest, channelKey) {
    var deferred, query;
    deferred = Q.defer();
    query = encodeURIComponent("key=\"" + channelKey + "\"");
    rest.GET("/channels?where=" + query, function(error, response, body) {
      var channel, channels;
      if (error) {
        deferred.reject('Error on getting channel: ' + error);
        return;
      }
      if (response.statusCode === 200) {
        channels = JSON.parse(body).results;
        if (_.size(channels) === 1) {
          deferred.resolve(channels[0]);
          return;
        }
      }
      channel = {
        key: channelKey
      };
      return rest.POST('/channels', JSON.stringify(channel), function(error, response, body) {
        var c;
        if (error) {
          return deferred.reject('Error on creating channel: ' + error);
        } else if (response.statusCode === 201) {
          c = JSON.parse(body);
          return deferred.resolve(c);
        } else {
          return deferred.reject('Problem on creating channel: ' + body);
        }
      });
    });
    return deferred.promise;
  };

  InventoryUpdater.prototype.allInventoryEntries = function(rest) {
    var deferred;
    deferred = Q.defer();
    rest.GET('/inventory?limit=0', function(error, response, body) {
      var stocks;
      if (error) {
        return deferred.reject('Error on getting all inventory entries: ' + error);
      } else if (response.statusCode !== 200) {
        return deferred.reject('Problem on getting all inventory entries: ' + body);
      } else {
        stocks = JSON.parse(body).results;
        return deferred.resolve(stocks);
      }
    });
    return deferred.promise;
  };

  InventoryUpdater.prototype.initMatcher = function() {
    var deferred,
      _this = this;
    deferred = Q.defer();
    this.allInventoryEntries(this.rest).then(function(existingEntries) {
      _this.existingInventoryEntries = existingEntries;
      return deferred.resolve(existingEntries);
    }).fail(function(msg) {
      return deferred.reject(msg);
    });
    return deferred.promise;
  };

  InventoryUpdater.prototype.match = function(s) {
    return _.find(this.existingInventoryEntries, function(entry) {
      if (entry.sku !== s.sku) {
        return false;
      }
      if (_.has(entry, CHANNEL_REF_NAME)) {
        if (_.has(s, CHANNEL_REF_NAME)) {
          if (entry[CHANNEL_REF_NAME].id === s[CHANNEL_REF_NAME].id) {
            return true;
          }
        }
      } else {
        if (!_.has(s, CHANNEL_REF_NAME)) {
          return true;
        }
      }
      return false;
    });
  };

  InventoryUpdater.prototype.createOrUpdate = function(inventoryEntries, callback) {
    var entry, existingEntry, posts, _i, _len;
    if (_.size(inventoryEntries) === 0) {
      return this.returnResult(true, 'Nothing to do.', callback);
    }
    posts = [];
    this.initProgressBar('Updating inventory', _.size(inventoryEntries));
    for (_i = 0, _len = inventoryEntries.length; _i < _len; _i++) {
      entry = inventoryEntries[_i];
      existingEntry = this.match(entry);
      if (existingEntry) {
        posts.push(this.update(entry, existingEntry));
      } else {
        posts.push(this.create(entry));
      }
    }
    return this.processInBatches(posts, callback);
  };

  InventoryUpdater.prototype.processInBatches = function(posts, callback, numberOfParallelRequest, acc) {
    var current,
      _this = this;
    if (numberOfParallelRequest == null) {
      numberOfParallelRequest = 50;
    }
    if (acc == null) {
      acc = [];
    }
    current = _.take(posts, numberOfParallelRequest);
    return Q.all(current).then(function(msg) {
      var messages;
      messages = acc.concat(msg);
      if (_.size(current) < numberOfParallelRequest) {
        return _this.returnResult(true, messages, callback);
      } else {
        return _this.processInBatches(_.tail(posts, numberOfParallelRequest), callback, numberOfParallelRequest, messages);
      }
    }).fail(function(msg) {
      return _this.returnResult(false, msg, callback);
    });
  };

  InventoryUpdater.prototype.update = function(entry, existingEntry) {
    var deferred,
      _this = this;
    deferred = Q.defer();
    this.sync.buildActions(entry, existingEntry).update(function(error, response, body) {
      _this.tickProgress();
      if (error) {
        return deferred.reject('Error on updating inventory entry: ' + error);
      } else {
        if (response.statusCode === 200) {
          return deferred.resolve('Inventory entry updated.');
        } else if (response.statusCode === 304) {
          return deferred.resolve('Inventory entry update not neccessary.');
        } else {
          return deferred.reject('Problem on updating existing inventory entry: ' + body);
        }
      }
    });
    return deferred.promise;
  };

  InventoryUpdater.prototype.create = function(stock) {
    var deferred,
      _this = this;
    deferred = Q.defer();
    this.rest.POST('/inventory', JSON.stringify(stock), function(error, response, body) {
      _this.tickProgress();
      if (error) {
        return deferred.reject('Error on creating new inventory entry: ' + error);
      } else {
        if (response.statusCode === 201) {
          return deferred.resolve('New inventory entry created.');
        } else {
          return deferred.reject('Problem on creating new inventory entry: ' + body);
        }
      }
    });
    return deferred.promise;
  };

  return InventoryUpdater;

})(CommonUpdater);

/*
Exports object
*/


module.exports = InventoryUpdater;
